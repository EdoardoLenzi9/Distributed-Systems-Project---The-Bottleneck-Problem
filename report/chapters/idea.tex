\chapter{The Idea}

Starting from the instantiation of a new car process we will describe the main aspects 
of a \textbf{car life-cycle}. 

As we said we model a car as a \textbf{finite state machine} 
with the following main states: sync, normal, leader, dead.\\

\noindent
One of the main problems of the project task is that there are some non trivial aspects 
that do not emerge in the initial analysis but are of fundamental importance; 
this happens cause the analysis takes into consideration only the problem 
that is located on an higher level with respect to the implementation and the 
architecture proposed.

First of all from the problem analysis is clear that the bridge is a shared resource 
so the problem can be solved with the solution exposed by Lamport in its 
article~\cite{Lamport:1978} about total ordering and synchronization. 

But this isn't the best choice cause total ordering requires a huge exchange of 
messages and, for this problem, is more than necessary; we decide to implement a 
custom algorithm based on the idea of locks.

Also leader election/distribute agreement algorithms are superfluous cause bridge 
access isn't contended by every car in a certain instant but, at most, 
by two concurrent cars on the opposite side; so a simple message exchange 
will be enough for the leader election. \\

\noindent
As stated above, we have to define new variables and notations; 
first of all we define a first layer cars as the set of car processes,
this layer sends periodically updates to a second layer of web service and 
database. Finally a third layer of clients make polling on the second layer.

Due to the asyncronicity, concurrency and time drifting is really hard 
to keep consistent the state of the cars layer with the simulation 
on the client layer. 
One way to keep an exact consistency can be to structure the algorithm on 
turns and only at the end of the turn, after the reaching of a global agreement,
launch a transactional update on the database layer. 
This way is for sure really safe but implies the implementation of some logic 
and a huge message exchange that overloads the network.

A simpler and less expensive idea (greedy) can be to leave a temporal inconsistency between 
layers state but avoid anomalous behaviours on the simulation side. \\

\noindent
Denote with $A \rightarrow B$ the partial order relation\footnote{
    To be precise $\rightarrow$ isn't a partial order relation cause it isn't 
    reflexive (a car cannot be behind itself) but only transitive and antisymmetric.
} between two cars $A$ and $B$ that are running from left to right and $A$ 
\textbf{is behind} $B$. 

So assume that in a certain instant $t_0$ 
(measured from an external and omniscient point of view) 
$A$ is in position $p_{A0}$ and B in $p_{B0}$ and 
the database layer state is consistent with the car layer state:

\begin{equation}\begin{split}
    state_{DB} = state_{Car}
\end{split}\end{equation} 

\noindent
Now before the next instant $t_1$ car $A$ moves forward of one block and car $B$
do the same after a while; we said after a while cause, as described by Lamport,
time is a continuous measure but clocks have a finite precision so 
ticks are discretizations of the time concept. 

For this reason if we consider a turn/tick 
of one second between $t_0$ and $t_1$ we realize that in this interval some 
actions can be made so consider the case in which A and B before $t_1$ 
have send two messages to the DB layer $A:p_{A1}$ and $B:p_{B1}$.

Now from the point of view of the database layer we cannot made any assumption 
about the incoming messages cause one or both of them can be lost and/or the 
arrival order can be different from the sending order. 

The more the third layer cannot have a consistent vision and, for example, 
can render the movement of $B$ before the transition of $A$ causing 
a visual crash (never happened).\\

\begin{tcolorbox}
\textbf{I)} Anomalous behaviours like that can easily be avoided ensuring that 
for each car must hold an order relation $\rightarrow$ and both movements 
and updates must be send respecting this relation.\\

In this way it is possible 
that the simulation renders $A$ in position $p_{A1}$ and $B$ in position 
$p_{B0}$ but this isn't a huge issue cause doesn't led to a crash so 
can be overlooked.
\end{tcolorbox}

\section{Init}

Init isn't properly a state cause cannot receive external events, 
is used only for 
\textit{Data}\footnote{\textbf{Data}: we denote as \textit{Data} 
the state persistent variables} 
initializations.


\section{Sync}

After FSM initialization the car reaches \textbf{sync state}, the main goals 
of this state are:

\begin{itemize}
    \item Synchronize with the other cars
    \item Set a consistent arrival time with the queue state 
    \item Set an initial position (safe, avoid spawn on the other cars)
    \item Send an update to the DB layer with the informations above
\end{itemize}

In order to perform a synchronization using Berkeley algorithm the new car needs to 
know a reference of the last car in the queue which is exposed by an end point; 
in order to avoid concurrency issues when a car calls the end point 
it becomes automatically the last car in the queue (with a transaction query).

This implies that any car is chained with the car in front of her and any other 
new car, from now on, cannot be interponed betweent them.\\

\noindent
If everything goes in the right way, at the end of the synchronization the new car ($A$) 
is located near the car in front of her ($B$) and the arrival time of $A$ must be 
higher then that of $B$.

We have also to guarantee \textbf{I} property so a car in sync state can synchronize 
itself with the database layer only after the car in front of her. Define 
$A:check(B)$ a check message from $A$ to $B$ that asks for the current $B$ state;
the message reply contains every relevant information about $B$ also its synchronization 
state, so is enough to wait until a check response state that B was just 
synchronized.  

If a check call doesn't have any reply, a timeout event will be triggered after 
$max_{RTT}$ ms. Once a car receives a timeout event calls a special process 
tow truck that has the duty of remove the broken cars.  

Once a car is removed by a tow truck the garbage process returns to the caller 
an update event that is then propagated to every other cars. For this kind of events 
the order isn't relevant, so even if we receive two concurrent updates of near cars 
we haven't to straggle to ordering them.


\section{Normal}

Sync was a static state, the car declares its initial position but has $speed_A = 0$;
normal is instead the state in which the car remains for the most of its life time and 
manages every car movement.

Assume that between two cars $A \rightarrow B$, in a certain instant $t_0$, 
there is a safety distance $d_{AB0}$; 
the car behind know this information because has sended a check message to the car 
in front of her and at instant $t_1$ receives a response.

Now $A$ is free to move forward (because $B$ can only move forward) of:

\begin{equation}\begin{split}
    & min\{\ d_{AB0},\ max\_speed * travel\_time \} \\
    & p_{Bi} \leq p_{Bj},\quad i < j \\
\end{split}\end{equation}    

Where $max\_speed$ is an arbitrary constant that constitute an upper bound for the speed 
and $travel\_time$ the time passed from the last car transition. 

Such as for sync also in this context we have to guarantee \textbf{I} property, so 
a car behind can move only after the car in front is synchronized with the DB layer.

Once a car reaches the bridge side and the car on the other side has an 
higher arrival time, the first car becomes the new leader.


\section{Leader}

Leader state is a static state such as sync, in this state the car notifies to 
the first $i$ rear cars the arrival time of of the car on the opposite side of the bridge 
(where $i$ is the bridge capacity) with a crossing message.

After the crossing propagation leader returns in the normal state in order to 
crossing the bridge. 

This simple leader election is safe, in the worst scenario 
the car in front can present a wrong arrival time due to a synchronization error 
but this at most cause the break of the FIFO order but never a car accident.


\section{Dead}

Once a car reaches the end of the bridge goes in the dead state and, 
after the sending of a global update event, the process stops.

A car can also reach dead from normal and leader states in case of an unexpected 
crash; in this case the car has to wait for a tow truck that removes it from the 
street. 