\chapter{Implementation}\label{ch:implementation}

In this chapter we will explain how the system was implemented, so we will describe 
technologies/languages, data structures, patterns and best practices used.


\section{Tools}


\subsection{Language}


The best choice between the languages exposed during the course seems to be 
\textbf{Erlang}~\cite{3}; 
in fact \textbf{Erlang OTP} allows to handle concurrency and distributed programming
moreover provides some \textbf{behaviours} really useful for this project:
\begin{itemize}
    \item \textbf{gen$\_$statem behaviour} allows to create a \textbf{finite state machine} 
        based on events (that fits perfectly with the nature of the problem);
    \item \textbf{gen$\_$server behaviour} allows to create a \textbf{web server}; 
        anyway for the web service implementation we prefer to use a more 
        rich and well documented \textbf{web framework} called \textbf{Cowboy}~\cite{4}  
\end{itemize}


\subsection{Web service}

Thanks to Cowboy we were able to implement a web service that exposes a \textbf{RESTful API}  
for both cars and simulation clients; we use \textbf{JSON}~\cite{6} as standard data interchange 
format for any interaction with the web service APIs.

The main reason of this decision is that it is, nowadays, a standard de facto and also 
versatile/\textbf{independent from the language} used 
(we use a library called \textbf{Jiffy}~\cite{5} for serialization/deserialization of data).


\subsubsection{Patterns and best practices}

The web service architecture follows the idea on the base of the \textbf{MVC pattern}; 
views, models and controllers were splitted and located in different files. 

The \textbf{front-end tier} is structured in views, stored in the same folder of the 
back-end code (for scope reasons). 
Each view can calls the server calling \textit{http-client.js} 
functions that use \textbf{AJAX}~\cite{12} for HTTP calls. 

The \textbf{back-end tier} follows also the \textbf{repository pattern} and 
\textbf{CRUD}~\cite{13} logic 
for what concerns the interaction with Mnesia. We decide to use the repository pattern 
in order to feel free, at any time, to change DBMS/connect with more than one DB without 
rewrite business logic code.

Mnesia is a no-SQL DBMS that basically works in a functional way (it is written in Erlang)
with tuples so it \textbf{isn't necessary any kind of ORM}~\cite{7} in order 
to map query results with Erlang data structures (and also avoid some issues of SQL 
like \lq\lq hard-coded\rq\rq\ queries and SQL-injection~\cite{8}).

Moreover every query, in particular \textbf{commands} (non idempotent query defined in 
CQRS~\cite{14} pattern), is made with a \textbf{transaction} so concurrency 
doesn't constitue an issue for this architecture.\\

\noindent
An HTTP call flow is really simple and clear; it starts from the \textbf{routing module} 
\textit{web$\_$service$\_$app.erl} that forwards the request to the right 
\textbf{controller}. In this passage we can also interpone some \textbf{middlewares} 
but the project doesn't require any.

\textbf{Controllers} are responsible for data unmarshalling and 
call \textbf{business logic routines}. 

The entire logic of the web service is 
stored into the \textbf{service layer} that has the duty to interact with 
the database using the interfaces exponed by the repositories and returns to 
the controller the expected results. For this reason in order to \textbf{test} 
the business logic is enough to test the utility functions used and exponed 
by the services.  

The module dependencies are: \textit{cowboy}, \textit{jiffy} and \textit{rebar3$\_$run} 
plugin; \textbf{dependency management} was delegated to \textbf{rebar3}~\cite{17} 
that uses internally HEX~\cite{18} package manger.


\subsection{UI}

UI is implemented using some famous front-end libraries collected with 
\textbf{npm}~\cite{16} package manager. 

Client UI can be used in any context so must have a \textbf{responsive layout} in order 
to fit any screen size; we use \textbf{Bootstrap}~\cite{19} and JQuery~\cite{20} 
in order to create a fluid layout. 

Moreover we though that the aesthetics of the simulation could be more appealing 
using \textbf{ThreeJS}~\cite{21} so we have injected in the main view a \textbf{3D canvas} 
where cars are rendered as blocks on a 2D street plane.


\subsection{Car}

Car is structured as a \textbf{finite state machine} with events, 
it has a \textbf{supervisor} that initializes the FSM and manages the interactions 
with the other cars and with the web service. 

The initial idea was to exclude the supervisor and call another car directly sending 
a message; this idea fails cause $gen\_statem$ behaviour doesn't allow to send/receive 
messages such as a normal node. 

So the behavior forces to \textbf{use the supervisor as an interface} with the FSM 
moreover we want to realize an asynchronous system for message exchange also 
capable to keep track of message RTT and other parameters. 

The solution was the creation of a little \textbf{timer subprocess} that manages the 
message exchange; this way was applicable but also a little complex because 
a message between two cars requires 8 hops (4 hops for the request and 4 hops for 
the response) so we implement a \textbf{pseudo multi-layer encapsulation} in order 
to create a generic asynchronous communication infrastructure.    

\begin{center}
    \includegraphics[scale=0.3]{assets/request-track.png}
    \captionof{figure}{Message exchange between two cars}
\end{center}
\begin{center}
    \includegraphics[scale=0.3]{assets/request-timeout.png}
    \captionof{figure}{A message without any reply triggers a timeout event}
\end{center}


\section{Docker}

At the end of the implementation the Erlang scripts were builded inside a docker image 
ready to be instantiated in a new container. 

Cars aren't aware, at compile time, of the \textbf{parameters} that characterize them 
(size, power, global settings, web server IP, etc.) so we exploit 
the docker feature to pass arguments with the \textit{run} call in order to 
\textbf{initialize the car}.  

Now the web service is sandboxed in a Docker container so in order to be able to launch 
bash commands (ie. to raise a new car instance) outside its scope we set up an 
\textbf{SSH tunnel}~\cite{15} toward the target host.


\section{Data structures}

As described in Chaper 1, cars and bridge must be aware about their characteristics.

In order to do that we have decided to create an environment file 
(\textit{environment.json}) that collects the default environment settings,
flanked by the UI that allows to update some settings.   


\subsection{Environment}

To model the environment the following attributes, which are set in environment.js for once, will be used:
\begin{itemize}
    \item $host$:\\ Web service IP:PORT
    \item $max\_speed$:\\ the maximun speed allowed
    \item $bridge\_capacity$: number\\ it defines the maximun number of cars that can cross the bridge
    at the same time
    \item $bridge\_length$: number\\ it defines the lenght of the bridge
    \item $tow\_truck\_time$: number\\ time necessary for the tow truck to arrive and remove the dead car
    \item $max\_RTT$:number\\ it is the maximun RTT that could happen
\end{itemize}

These attributes will never be modified during the simulation.

\subsection{Car}

Each car A is modelled exploiting the following attributes:
\begin{itemize}
    \item $name$: number\\ it identifies univocally the car
    \item $side$: number\\ if equal to 1 means that the car is on the right side, 
    if equal to -1 it means that it is on left side
    \item $power$: number\\ it defines the number of rear and front cars that the car can reach
    \item $size$: number \\ it defines the lenght of the car
    \item $speed$: number\\ it defines the distance that the car goes through in one turn\\
    it has a maximun value specified in \textbf{environment.js}\\
    it is initialized with 0 to prevent crashing 
    \item $position$: number \\it indicates the distance between the car and the bridge or the car and the end of the
    bridge\\it is initialized as $pos(B)+1*side(B)$, where B is the first front car, if B is on the same side of A, or
    as $-pos(B)$ if B is on the other side\\ when negative it means that the car is on the left side, otherwise on the right side
    \item $crossing$: boolean\\ if true it means that the car is on the bridge
    \item $syncrhonized$: boolean\\ if true it means that the car is syncrhonized    
    \item $delta$: number\\ it is the difference between the local time and the global time
    \item $arrival\_time$: number\\ it defines the time when the car has arrived in the queue
    \item $current\_time$: number\\ it indicates the local time at each turn
    \item $adj$: another data structure\\ it contains the lists of front and rear cars
    \item $state$: string\\ it defines the current state of the car\\ it could be \textbf{init}, \textbf{sync}, \textbf{normal} or \textbf{dead}
\end{itemize}
These above are the car metadata, while the following are settings and bridge metadata 
(these are taken from the environment definition but must be part of the car specifics too):
\begin{itemize}
    \item $host$:\\ Web service IP:PORT
    \item $bridge\_capacity$: number\\ it defines the maximun number of cars that can cross the bridge
    at the same time
    \item $bridge\_length$: number\\ it defines the lenght of the bridge
    \item $max\_speed$:\\ the maximun speed allowed
    \item $tow\_truck\_time$: number\\ time necessary for the tow truck to arrive and remove the dead car
    \item $max\_RTT$:number\\ it is the maximun RTT that could happen
\end{itemize}

Note that $bridge\_capacity$ and $bridge\_length$ are imposed by the environment and cannot change during the
simulation. Furthermore $name$ and $power$ are defined independently, while $delta$ and $adj$ 
depend on the other cars.\\

The problem allows to describe the car as a finite state machine. We choose this modality because
the car can switch between four main different states. The first one is a so called \textbf{init}: the 
undefined attributes are computed here. It is assumed that in this state the car cannot receive
any sort of event and that cannot crash. \\
When the car is syncrhonized it changes its state in \textbf{sync}: the car call the web service to receive the list of adiacents cars. 
When it is received the car knows how to communicate with the current front car and so can define its $speed$ and $position$ according to
the state of the front car. Finally thee car can change its state to \textbf{normal}.\\
In \textbf{normal} the car still sends repeatedly a check event to the front car in order to regolate hers speed
(and consequently the new position).\\
In particular, at every iteration, the car computes the following function to determinate the 
new $speed$: \[\frac{pos(A)-pos(B)}{RTT + turn}\] 
and the new $position$: \[pos(A) + \frac{|pos(A)-pos(B)|}{RTT + turn}\]
where $pos(x)$ = $position$ of x. \\
Obviously this means that if the distance between A and B is zero, the car will change its speed to 
zero: this avoids crashing during the next turn even if the front car says that its $speed$ is greater
then zero. In fact, if B crashes immediately after sending its state, the other car assumes that B
is moving and so she decides to move too ending up colliding with B.\\ When the car finally reach the position
zero she become a leader and so its state would be the \textbf{leader} state. If there is a car B on the opposite side 
(that can be in the leader state too), they have to decide who will start crossing:
\begin{itemize}
    \item if A's $crossing$ attribute is true and her arrival time is less than B's,
     she start crossing the bridge
    \item if A's $crossing$ attribute is false and her arrival time is less than B's,
     she change it to true
    \item if A's arrival time is greater than B's, she stops and waits her turn
\end{itemize}

When it's its turn, the car change its $position$, that will be equal to the bridge lenght, and its $speed$,
that will be the maximun speed allowed. Before changing state to normal the car has also to propagate to the first n cars behind her (n is equal to the bridge capacity) 
to change $crossing$ value to true. After that she moves and returns to the \textbf{normal} state.\\
Obviously there is another state called $\textbf{dead}$ that could be reached from every state, except for \textbf{init}, 
when the car's engine or the car's engine and system crash or when the car completes the crossing. 
In the first case the car cannot move anymore and so somebody (the car itself or the first behind her)
 must call the tow truck to be removed. Anyway the car must send periodically a check message to the others
in order to find out if one is dead. \\Notice that if there is a car whose $speed$ = 0 it may mean that the car is stationary, waiting the front
 car to move, or in \textbf{dead} status.\\

\subsubsection{Communication}

It is important to underline how two cars can send message to each other. \\
First of all, each car has a supervisor and, when a car A want to send something to another car B,
this happens:
\begin{itemize}
   \item[1.] A sends a message to hers supervisor S$_{A}$
   \item [2.] S$_{A}$ calls a process, we can refer at it as $Timer$, which is used to send a timeout
   if the supervisor didn't receive a response from the other within a certain time. In that case S$_{A}$ assumes 
   that B is dead and so A will call a tow truck to remove it.
   \item[3.] S$_{A}$ sends it to the supervisor of B S$_{B}$
   \item [4.] S$_{B}$ sends an event to B which contains the message of A
   \item [5.] B send a message to S$_{B}$ whit the response
   \item [6.] S$_{B}$ sends it to S$_{A}$, going through the $Timer$ as S$_{A}$ has done at point 2
   \item [7.] finally S$_{A}$ sends another event to A with the response of B, to which A reacts appropiately
\end{itemize}

\subsection{Adj}
We used another data structure for the adiacents cars, called $adj$:
\begin{itemize}
    \item $front\_cars$: list of cars\\ it contains all the car ahead that are rechable\\ the first element
     is the next car
    \item $rear\_cars$: list of cars\\ it contains all the car behind that are rechable\\ the last element
     is the previous car
\end{itemize} 